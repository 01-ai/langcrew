---
title: File Detection
description: Intelligent file type detection and content analysis
---

LangCrew's file detection utilities provide intelligent file type detection using multiple heuristic rules, supporting binary/text classification and content analysis.

## Overview

The file detection module (`langcrew.utils.file_detect`) offers:
- **Binary vs Text Detection**: Reliable classification using null bytes, encoding validation, and signatures
- **File Type Hints**: Specific file type identification (images, executables, documents, scripts)
- **Multi-encoding Support**: Handles Chinese text and various character encodings
- **Content Analysis**: Deep inspection beyond file extensions

## Basic Usage

### Binary/Text Classification

```python
from langcrew.utils.file_detect import is_binary_file, is_text_file

# Read file content
with open("document.pdf", "rb") as f:
    content = f.read()

# Check if binary
if is_binary_file(content):
    print("Binary file detected")
else:
    print("Text file detected")

# Alternative check
if is_text_file(content):
    print("Text file confirmed")
```

### File Type Detection

```python
from langcrew.utils.file_detect import get_file_type_hint

# Get specific file type
with open("image.png", "rb") as f:
    content = f.read()

file_type = get_file_type_hint(content)
print(f"File type: {file_type}")  # "PNG image"
```

## Detection Methods

### 1. Signature-Based Detection

The module recognizes common file signatures:

```python
# Supported signatures
signatures = {
    b"\x89PNG\r\n\x1a\n": "PNG image",
    b"GIF87a": "GIF image", 
    b"\xff\xd8\xff": "JPEG image",
    b"%PDF": "PDF document",
    b"PK\x03\x04": "ZIP archive",
    b"\x7fELF": "ELF executable",
    b"MZ": "Windows executable",
    # ... and many more
}
```

### 2. Encoding Validation

```python
# The module attempts multiple encodings
encodings = ["utf-8", "gbk", "gb2312", "big5", "utf-16", "latin-1"]

# Example: Chinese text detection
chinese_text = "这是中文文本".encode("utf-8")
assert is_text_file(chinese_text) == True
```

### 3. Content Analysis

```python
# Heuristic rules applied:
# 1. Null byte presence (most reliable)
# 2. Non-printable character ratio
# 3. Control character analysis
# 4. UTF-8/UTF-16 validation
# 5. Binary signature matching
```

## Advanced Usage

### Custom Detection Logic

```python
from langcrew.utils.file_detect import is_binary_file, get_file_type_hint

def analyze_file(file_path: str) -> dict:
    """Comprehensive file analysis"""
    with open(file_path, "rb") as f:
        content = f.read()
    
    return {
        "path": file_path,
        "is_binary": is_binary_file(content),
        "type_hint": get_file_type_hint(content),
        "size": len(content),
        "empty": len(content) == 0
    }

# Example usage
result = analyze_file("document.pdf")
print(result)
# {
#     "path": "document.pdf",
#     "is_binary": True,
#     "type_hint": "PDF document", 
#     "size": 245760,
#     "empty": False
# }
```

### Batch File Processing

```python
import os
from pathlib import Path

def scan_directory(directory: str) -> dict:
    """Scan directory and classify all files"""
    results = {"binary": [], "text": [], "unknown": []}
    
    for file_path in Path(directory).rglob("*"):
        if file_path.is_file():
            try:
                with open(file_path, "rb") as f:
                    content = f.read(1024)  # Read first 1KB for efficiency
                
                if is_binary_file(content):
                    results["binary"].append(str(file_path))
                else:
                    results["text"].append(str(file_path))
            except Exception:
                results["unknown"].append(str(file_path))
    
    return results
```

## Supported File Types

### Binary Files
- **Images**: PNG, JPEG, GIF, BMP, ICO
- **Archives**: ZIP, GZIP, TAR
- **Executables**: ELF (Linux), PE (Windows)
- **Media**: MP4, WAV, AVI (RIFF containers)
- **Documents**: PDF

### Text Files
- **Code**: Python, JavaScript, Java, C/C++, PHP
- **Markup**: HTML, XML
- **Scripts**: Shell scripts (#!/bin/bash)
- **Data**: JSON, CSV, YAML
- **Documentation**: Markdown, plain text

### Multi-language Support
- **Chinese**: UTF-8, GBK, GB2312, Big5
- **Unicode**: UTF-8, UTF-16 (with BOM detection)
- **Legacy**: Latin-1, ASCII

## Performance Considerations

### Efficient Detection

```python
# For large files, read only the beginning
def quick_detect(file_path: str, sample_size: int = 8192) -> bool:
    """Quick binary detection using file sample"""
    with open(file_path, "rb") as f:
        sample = f.read(sample_size)
    return is_binary_file(sample)
```

### Memory Usage

```python
# For very large files, use streaming
def stream_detect(file_path: str) -> bool:
    """Memory-efficient detection for large files"""
    with open(file_path, "rb") as f:
        # Check first 8KB - usually sufficient
        chunk = f.read(8192)
        return is_binary_file(chunk)
```

## Integration Examples

### With File Processing Pipeline

```python
from langcrew.utils.file_detect import is_text_file, get_file_type_hint

def process_uploaded_file(file_path: str):
    """Process uploaded file based on type"""
    with open(file_path, "rb") as f:
        content = f.read()
    
    if is_text_file(content):
        # Process as text
        text_content = content.decode("utf-8")
        return {"type": "text", "content": text_content}
    else:
        # Handle binary file
        file_type = get_file_type_hint(content)
        return {"type": "binary", "file_type": file_type, "size": len(content)}
```

### With Agent File Processing

```python
from langcrew import Agent
from langcrew.utils.file_detect import is_text_file

def create_file_processor_agent():
    """Agent that processes files intelligently"""
    
    def file_analysis_tool(file_path: str) -> str:
        with open(file_path, "rb") as f:
            content = f.read()
        
        if is_text_file(content):
            # Return text content for agent processing
            return content.decode("utf-8", errors="ignore")
        else:
            # Return metadata for binary files
            file_type = get_file_type_hint(content)
            return f"Binary file detected: {file_type}, Size: {len(content)} bytes"
    
    return Agent(
        role="File Processor",
        goal="Analyze and process files based on their type",
        backstory="You intelligently handle different file types",
        tools=[file_analysis_tool]
    )
```

## Error Handling

```python
from langcrew.utils.file_detect import is_binary_file

def safe_file_detection(file_path: str) -> dict:
    """Safe file detection with error handling"""
    try:
        with open(file_path, "rb") as f:
            content = f.read()
        
        return {
            "success": True,
            "is_binary": is_binary_file(content),
            "type_hint": get_file_type_hint(content)
        }
    except FileNotFoundError:
        return {"success": False, "error": "File not found"}
    except PermissionError:
        return {"success": False, "error": "Permission denied"}
    except Exception as e:
        return {"success": False, "error": str(e)}
```

## Next Steps

- **[Token Counting](/guides/utils/token-counting)** - Precise token counting for LLMs
- **[Language Detection](/guides/utils/language-detection)** - Detect text language
- **[Message Utilities](/guides/utils/message-utilities)** - Message ID generation
- **[Utils Concepts](/concepts/utils)** - Understanding utility functions