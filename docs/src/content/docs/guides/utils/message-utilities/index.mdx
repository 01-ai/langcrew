---
title: Message Utilities
description: Message ID generation and message handling utilities
---

LangCrew's message utilities provide essential functions for message ID generation and message-related operations in distributed systems and multi-agent environments.

## Overview

The message utilities module (`langcrew.utils.message_utils`) offers:
- **Unique ID Generation**: Time-based message IDs with collision avoidance
- **High Concurrency Support**: Random suffixes prevent ID conflicts
- **Lightweight**: No external dependencies, fast performance
- **Predictable Format**: Consistent timestamp-based format for sorting and debugging

## Basic Usage

### Generate Message IDs

```python
from langcrew.utils.message_utils import generate_message_id

# Generate unique message ID
message_id = generate_message_id()
print(message_id)  # Example: "1748438204041_a7k9"

# Generate multiple IDs
ids = [generate_message_id() for _ in range(5)]
print(ids)
# ['1748438204041_b2x5', '1748438204041_m9k3', '1748438204042_p4n7', ...]
```

## ID Format Structure

### Format Specification

```python
# Format: {timestamp_ms}_{random_suffix}
# - timestamp_ms: Unix timestamp in milliseconds
# - random_suffix: 4-character alphanumeric string

# Example breakdown:
message_id = "1748438204041_a7k9"
#            └─────────────┘ └──┘
#            timestamp_ms   suffix
```

### Components

```python
import time
import re

def parse_message_id(message_id: str) -> dict:
    """Parse message ID components"""
    pattern = r"^(\d+)_([a-z0-9]{4})$"
    match = re.match(pattern, message_id)
    
    if not match:
        return {"valid": False, "error": "Invalid format"}
    
    timestamp_ms, suffix = match.groups()
    timestamp_ms = int(timestamp_ms)
    
    return {
        "valid": True,
        "timestamp_ms": timestamp_ms,
        "timestamp_s": timestamp_ms / 1000,
        "suffix": suffix,
        "datetime": time.ctime(timestamp_ms / 1000)
    }

# Example usage
message_id = generate_message_id()
parsed = parse_message_id(message_id)
print(parsed)
# {
#     "valid": True,
#     "timestamp_ms": 1748438204041,
#     "timestamp_s": 1748438204.041,
#     "suffix": "a7k9",
#     "datetime": "Mon Jan 27 12:30:04 2025"
# }
```

## Advanced Usage

### Batch ID Generation

```python
from langcrew.utils.message_utils import generate_message_id

def generate_message_batch(count: int) -> list[str]:
    """Generate batch of unique message IDs"""
    return [generate_message_id() for _ in range(count)]

def generate_prefixed_ids(prefix: str, count: int) -> list[str]:
    """Generate IDs with custom prefix"""
    base_ids = generate_message_batch(count)
    return [f"{prefix}_{id}" for id in base_ids]

# Example usage
batch_ids = generate_message_batch(10)
prefixed_ids = generate_prefixed_ids("chat", 5)

print(f"Batch IDs: {batch_ids[:3]}...")
print(f"Prefixed IDs: {prefixed_ids}")
```

### ID Validation and Sorting

```python
import re
from langcrew.utils.message_utils import generate_message_id

def validate_message_id(message_id: str) -> bool:
    """Validate message ID format"""
    pattern = r"^\d+_[a-z0-9]{4}$"
    return bool(re.match(pattern, message_id))

def sort_message_ids(message_ids: list[str]) -> list[str]:
    """Sort message IDs chronologically"""
    def extract_timestamp(msg_id: str) -> int:
        try:
            return int(msg_id.split('_')[0])
        except (ValueError, IndexError):
            return 0
    
    return sorted(message_ids, key=extract_timestamp)

# Example usage
ids = [generate_message_id() for _ in range(5)]
print("Original:", ids)
print("Sorted:", sort_message_ids(ids))
print("All valid:", all(validate_message_id(id) for id in ids))
```

## Integration Examples

### With Message Queuing

```python
from langcrew.utils.message_utils import generate_message_id
import json
from typing import Any

class MessageQueue:
    """Simple message queue with unique IDs"""
    
    def __init__(self):
        self.messages = []
    
    def send_message(self, content: Any, sender: str = "system") -> str:
        """Send message with unique ID"""
        message_id = generate_message_id()
        
        message = {
            "id": message_id,
            "content": content,
            "sender": sender,
            "timestamp": int(message_id.split('_')[0])
        }
        
        self.messages.append(message)
        return message_id
    
    def get_message(self, message_id: str) -> dict | None:
        """Retrieve message by ID"""
        for msg in self.messages:
            if msg["id"] == message_id:
                return msg
        return None
    
    def get_recent_messages(self, limit: int = 10) -> list[dict]:
        """Get recent messages, sorted by timestamp"""
        sorted_messages = sorted(self.messages, 
                               key=lambda x: x["timestamp"], 
                               reverse=True)
        return sorted_messages[:limit]

# Example usage
queue = MessageQueue()

# Send messages
id1 = queue.send_message("Hello world", "user")
id2 = queue.send_message("How are you?", "user")
id3 = queue.send_message("I'm fine, thanks!", "assistant")

# Retrieve messages
print(f"Message {id1}: {queue.get_message(id1)}")
print(f"Recent messages: {queue.get_recent_messages(2)}")
```

### With Agent Communication

```python
from langcrew import Agent
from langcrew.utils.message_utils import generate_message_id

class CommunicationAgent(Agent):
    """Agent with message tracking capabilities"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.message_history = []
    
    def send_message(self, content: str, recipient: str = "system") -> str:
        """Send tracked message"""
        message_id = generate_message_id()
        
        message = {
            "id": message_id,
            "content": content,
            "sender": self.role,
            "recipient": recipient,
            "timestamp": int(message_id.split('_')[0])
        }
        
        self.message_history.append(message)
        return message_id
    
    def get_conversation_history(self, with_agent: str = None) -> list[dict]:
        """Get conversation history, optionally filtered by agent"""
        if with_agent:
            return [msg for msg in self.message_history 
                   if msg["recipient"] == with_agent or msg["sender"] == with_agent]
        return self.message_history
    
    def get_message_stats(self) -> dict:
        """Get message statistics"""
        if not self.message_history:
            return {"total": 0, "recipients": [], "avg_length": 0}
        
        recipients = list(set(msg["recipient"] for msg in self.message_history))
        avg_length = sum(len(msg["content"]) for msg in self.message_history) / len(self.message_history)
        
        return {
            "total": len(self.message_history),
            "recipients": recipients,
            "avg_length": avg_length
        }

# Example usage
agent = CommunicationAgent(
    role="Communication Specialist",
    goal="Track and manage message communications",
    backstory="You maintain detailed message logs"
)

# Send messages
agent.send_message("Hello team", "broadcast")
agent.send_message("Status update", "manager")
agent.send_message("Task completed", "system")

# Get statistics
stats = agent.get_message_stats()
print(f"Message stats: {stats}")
```

### With Streaming Systems

```python
from langcrew.utils.message_utils import generate_message_id
import asyncio
from typing import AsyncGenerator

class StreamingMessageHandler:
    """Handle streaming messages with unique IDs"""
    
    def __init__(self):
        self.active_streams = {}
    
    async def create_stream(self, stream_name: str) -> str:
        """Create new message stream"""
        stream_id = generate_message_id()
        self.active_streams[stream_id] = {
            "name": stream_name,
            "messages": [],
            "created_at": int(stream_id.split('_')[0])
        }
        return stream_id
    
    async def add_message_to_stream(self, stream_id: str, content: str) -> str:
        """Add message to stream"""
        if stream_id not in self.active_streams:
            raise ValueError(f"Stream {stream_id} not found")
        
        message_id = generate_message_id()
        message = {
            "id": message_id,
            "content": content,
            "stream_id": stream_id,
            "timestamp": int(message_id.split('_')[0])
        }
        
        self.active_streams[stream_id]["messages"].append(message)
        return message_id
    
    async def stream_messages(self, stream_id: str) -> AsyncGenerator[dict, None]:
        """Stream messages from a stream"""
        if stream_id not in self.active_streams:
            raise ValueError(f"Stream {stream_id} not found")
        
        for message in self.active_streams[stream_id]["messages"]:
            yield message
            await asyncio.sleep(0.1)  # Simulate streaming delay

# Example usage
async def streaming_example():
    handler = StreamingMessageHandler()
    
    # Create stream
    stream_id = await handler.create_stream("chat_session")
    
    # Add messages
    await handler.add_message_to_stream(stream_id, "Hello")
    await handler.add_message_to_stream(stream_id, "How are you?")
    await handler.add_message_to_stream(stream_id, "Goodbye")
    
    # Stream messages
    async for message in handler.stream_messages(stream_id):
        print(f"Message {message['id']}: {message['content']}")

# Run example
# asyncio.run(streaming_example())
```

## Performance Considerations

### High-Concurrency ID Generation

```python
from langcrew.utils.message_utils import generate_message_id
import threading
from collections import defaultdict

def test_id_uniqueness(num_threads: int = 10, ids_per_thread: int = 1000):
    """Test ID uniqueness under high concurrency"""
    all_ids = []
    id_lock = threading.Lock()
    
    def generate_ids():
        """Generate IDs in thread"""
        thread_ids = [generate_message_id() for _ in range(ids_per_thread)]
        
        with id_lock:
            all_ids.extend(thread_ids)
    
    # Create and start threads
    threads = []
    for _ in range(num_threads):
        thread = threading.Thread(target=generate_ids)
        threads.append(thread)
        thread.start()
    
    # Wait for completion
    for thread in threads:
        thread.join()
    
    # Check uniqueness
    unique_ids = set(all_ids)
    total_generated = num_threads * ids_per_thread
    
    return {
        "total_generated": total_generated,
        "unique_count": len(unique_ids),
        "duplicates": total_generated - len(unique_ids),
        "success_rate": len(unique_ids) / total_generated
    }

# Test uniqueness
result = test_id_uniqueness(20, 500)
print(f"Uniqueness test: {result}")
```

### Memory-Efficient ID Management

```python
from langcrew.utils.message_utils import generate_message_id
from collections import deque

class LimitedMessageStore:
    """Memory-efficient message store with ID tracking"""
    
    def __init__(self, max_messages: int = 1000):
        self.max_messages = max_messages
        self.messages = deque(maxlen=max_messages)
        self.id_index = {}
    
    def add_message(self, content: str) -> str:
        """Add message with automatic cleanup"""
        message_id = generate_message_id()
        message = {"id": message_id, "content": content}
        
        # Remove oldest message from index if at capacity
        if len(self.messages) == self.max_messages:
            oldest = self.messages[0]
            if oldest["id"] in self.id_index:
                del self.id_index[oldest["id"]]
        
        # Add new message
        self.messages.append(message)
        self.id_index[message_id] = len(self.messages) - 1
        
        return message_id
    
    def get_message(self, message_id: str) -> dict | None:
        """Get message by ID"""
        if message_id in self.id_index:
            index = self.id_index[message_id]
            if 0 <= index < len(self.messages):
                return self.messages[index]
        return None
```

## Error Handling

```python
from langcrew.utils.message_utils import generate_message_id

def safe_message_id_generation(retries: int = 3) -> str:
    """Generate message ID with retry logic"""
    for attempt in range(retries):
        try:
            message_id = generate_message_id()
            
            # Validate generated ID
            if not message_id or '_' not in message_id:
                raise ValueError("Invalid message ID generated")
            
            return message_id
            
        except Exception as e:
            if attempt == retries - 1:
                # Last attempt failed
                raise RuntimeError(f"Failed to generate message ID after {retries} attempts: {e}")
            
            # Wait before retry (simple backoff)
            import time
            time.sleep(0.001 * (attempt + 1))
    
    raise RuntimeError("Unexpected error in message ID generation")

# Example usage with error handling
def create_message_with_fallback(content: str) -> dict:
    """Create message with fallback ID generation"""
    try:
        message_id = generate_message_id()
    except Exception:
        # Fallback to simple timestamp
        import time
        message_id = f"fallback_{int(time.time() * 1000)}"
    
    return {
        "id": message_id,
        "content": content,
        "created_with_fallback": "fallback_" in message_id
    }
```

## Best Practices

### 1. Use Consistent ID Format

```python
# Good: Use the standard format
from langcrew.utils.message_utils import generate_message_id

message_id = generate_message_id()  # "1748438204041_a7k9"

# Avoid: Custom formats that break compatibility
custom_id = f"msg_{time.time()}"  # Breaks sorting and parsing
```

### 2. Store IDs for Tracking

```python
class MessageTracker:
    """Track messages with proper ID management"""
    
    def __init__(self):
        self.messages = {}
        self.id_history = []
    
    def create_message(self, content: str) -> str:
        """Create and track message"""
        message_id = generate_message_id()
        
        self.messages[message_id] = {
            "content": content,
            "created_at": int(message_id.split('_')[0])
        }
        self.id_history.append(message_id)
        
        return message_id
```

### 3. Handle ID Collisions Gracefully

```python
def safe_id_with_collision_check(existing_ids: set) -> str:
    """Generate ID with collision avoidance"""
    max_attempts = 100
    
    for _ in range(max_attempts):
        new_id = generate_message_id()
        if new_id not in existing_ids:
            return new_id
    
    # If we somehow get here, add extra randomness
    import uuid
    return f"{generate_message_id()}_{uuid.uuid4().hex[:4]}"
```

## Next Steps

- **[File Detection](/guides/utils/file-detection)** - Intelligent file type detection
- **[Token Counting](/guides/utils/token-counting)** - Precise token counting for LLMs
- **[Language Detection](/guides/utils/language-detection)** - Detect text language
- **[Utils Concepts](/concepts/utils)** - Understanding utility functions