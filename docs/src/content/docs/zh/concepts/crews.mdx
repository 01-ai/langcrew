---
title: 团队 (Crews)
description: 理解团队 - 协调智能体合作完成复杂任务的编排器
---

团队是LangCrew的核心编排器，负责协调多个智能体之间的协作，确保任务按正确顺序执行，并管理整体工作流程。

## 什么是团队？

团队在langcrew中提供：
- **智能体协调**：管理多个智能体之间的交互和协作
- **任务编排**：确保任务按正确依赖顺序执行
- **流程控制**：控制执行流程，包括并行和顺序处理
- **共享上下文**：在智能体之间维护共享状态和信息

## 基本用法

### 简单团队

```python
from langcrew import Agent, Task, Crew

# 创建智能体
researcher = Agent(
    role="研究员",
    goal="收集相关信息",
    backstory="专门收集和分析信息的专家"
)

writer = Agent(
    role="作家",
    goal="创建引人入胜的内容",
    backstory="专门创建高质量书面内容的专家"
)

# 创建任务
research_task = Task(
    description="研究AI在医疗保健中的最新趋势",
    agent=researcher
)

write_task = Task(
    description="基于研究写一篇关于AI在医疗保健中的文章",
    agent=writer
)

# 创建团队
crew = Crew(
    agents=[researcher, writer],
    tasks=[research_task, write_task],
    verbose=True
)
```

## 团队配置

### 核心参数


### 高级配置示例

```python
from langcrew import Crew, Process
from langcrew.memory import LongTermMemory

crew = Crew(
    agents=[agent1, agent2, agent3],
    tasks=[task1, task2, task3],
    process=Process.hierarchical,
    memory=LongTermMemory(),
    verbose=True,
    language="zh",
    max_rpm=100,
    step_callback=lambda step: print(f"步骤完成: {step}"),
    task_callback=lambda task: print(f"任务完成: {task}")
)
```

## 执行流程

### 顺序流程 (Sequential)

默认执行模式，任务按定义顺序依次执行：

```python
crew = Crew(
    agents=[researcher, writer],
    tasks=[research_task, write_task],
    process=Process.sequential
)

# 执行：research_task -> write_task
result = crew.kickoff()
```

### 并行流程 (Parallel)

任务可以并行执行（如果没有依赖关系）：

```python
crew = Crew(
    agents=[agent1, agent2, agent3],
    tasks=[independent_task1, independent_task2],
    process=Process.parallel
)

result = crew.kickoff()
```

### 层级流程 (Hierarchical)

带有管理者智能体的层级结构：

```python
manager = Agent(
    role="项目经理",
    goal="协调团队并确保质量",
    backstory="经验丰富的项目管理专家"
)

crew = Crew(
    agents=[manager, researcher, writer],
    tasks=[research_task, write_task],
    process=Process.hierarchical,
    manager_llm=ChatOpenAI(model="gpt-4")
)
```

## 记忆系统

### 短期记忆

```python
crew = Crew(
    agents=[agent1, agent2],
    tasks=[task1, task2],
    memory=True  # 启用默认短期记忆
)
```

### 长期记忆

```python
from langcrew.memory import LongTermMemory

crew = Crew(
    agents=[agent1, agent2],
    tasks=[task1, task2],
    memory=LongTermMemory(
        provider="chroma",
        config={
            "chroma_db_path": "./crew_memory"
        }
    )
)
```

### 自定义记忆

```python
from langcrew.memory import BaseMemory

class CustomMemory(BaseMemory):
    def save(self, data):
        # 自定义保存逻辑
        pass
    
    def search(self, query):
        # 自定义搜索逻辑
        pass

crew = Crew(
    agents=[agent1, agent2],
    tasks=[task1, task2],
    memory=CustomMemory()
)
```

## 人机协作 (HITL)

### 基本HITL配置

```python
from langcrew.hitl import HITLConfig

hitl_config = HITLConfig(
    enabled=True,
    interrupt_before_tools=["critical_decision"],
    interrupt_after_tools=["analysis_complete"]
)

crew = Crew(
    agents=[decision_agent, analysis_agent],
    tasks=[decision_task, analysis_task],
    hitl=hitl_config
)
```

## 执行方法

### 同步执行

```python
# 基本执行
result = crew.kickoff()

# 带输入的执行
result = crew.kickoff(inputs={"topic": "人工智能"})

# 带回调的执行
def step_callback(step):
    print(f"步骤: {step}")

result = crew.kickoff(step_callback=step_callback)
```

### 异步执行

```python
import asyncio

async def run_crew():
    result = await crew.kickoff_async()
    return result

# 运行异步团队
result = asyncio.run(run_crew())
```

### 流式执行

```python
# 流式获取执行事件
for event in crew.kickoff_for_each():
    print(f"事件: {event}")

# 异步流式执行
async for event in crew.kickoff_async_for_each():
    print(f"异步事件: {event}")
```

## 回调系统

### 步骤回调

在每个执行步骤后调用：

```python
def step_callback(step):
    print(f"完成步骤: {step.description}")
    print(f"输出: {step.output}")

crew = Crew(
    agents=[agent],
    tasks=[task],
    step_callback=step_callback
)
```

### 任务回调

在每个任务完成后调用：

```python
def task_callback(task):
    print(f"任务完成: {task.description}")
    print(f"智能体: {task.agent.role}")
    print(f"结果: {task.output}")

crew = Crew(
    agents=[agent],
    tasks=[task],
    task_callback=task_callback
)
```

## 错误处理

### 基本错误处理

```python
try:
    result = crew.kickoff()
except Exception as e:
    print(f"团队执行失败: {e}")
```

### 自定义错误处理

```python
from langcrew.exceptions import TaskExecutionError

def error_handler(error, task, agent):
    if isinstance(error, TaskExecutionError):
        print(f"任务 {task.description} 在智能体 {agent.role} 上失败")
        # 自定义恢复逻辑
        return "默认输出"
    raise error

crew = Crew(
    agents=[agent],
    tasks=[task],
    error_handler=error_handler
)
```

## 性能优化

### 缓存配置

```python
crew = Crew(
    agents=[agent1, agent2],
    tasks=[task1, task2],
    cache=True,  # 启用结果缓存
    cache_handler=CustomCacheHandler()  # 自定义缓存处理器
)
```

### 速率限制

```python
crew = Crew(
    agents=[agent1, agent2],
    tasks=[task1, task2],
    max_rpm=60,  # 每分钟最大60个请求
    max_execution_time=300  # 最大执行时间5分钟
)
```

## 监控和日志

### 详细日志

```python
crew = Crew(
    agents=[agent],
    tasks=[task],
    verbose=True,  # 启用详细日志
    output_log_file="crew_execution.log"
)
```

### 自定义日志

```python
import logging

# 配置自定义日志器
logger = logging.getLogger("crew_logger")
handler = logging.FileHandler("custom_crew.log")
logger.addHandler(handler)

crew = Crew(
    agents=[agent],
    tasks=[task],
    logger=logger
)
```

## 高级模式

### 条件执行

```python
def should_execute_task(task, context):
    return context.get("condition", False)

crew = Crew(
    agents=[agent],
    tasks=[conditional_task],
    task_condition=should_execute_task
)
```

### 动态任务生成

```python
def generate_tasks(context):
    tasks = []
    for item in context.get("items", []):
        task = Task(
            description=f"处理 {item}",
            agent=processor_agent
        )
        tasks.append(task)
    return tasks

crew = Crew(
    agents=[processor_agent],
    tasks=[],
    dynamic_task_generator=generate_tasks
)
```

### 智能体协作模式

```python
# 智能体间共享上下文
crew = Crew(
    agents=[agent1, agent2, agent3],
    tasks=[task1, task2, task3],
    share_crew=True,  # 智能体可以访问团队上下文
    collaboration_mode="consensus"  # 需要智能体达成共识
)
```

## 部署考虑

### 生产配置

```python
from langcrew.monitoring import MetricsCollector
from langcrew.security import SecurityManager

crew = Crew(
    agents=[agent1, agent2],
    tasks=[task1, task2],
    metrics_collector=MetricsCollector(),
    security_manager=SecurityManager(),
    max_retries=3,
    retry_delay=5.0,
    timeout=600
)
```

### 分布式执行

```python
from langcrew.distributed import DistributedCrew

distributed_crew = DistributedCrew(
    agents=[agent1, agent2],
    tasks=[task1, task2],
    cluster_config={
        "nodes": ["node1", "node2", "node3"],
        "load_balancer": "round_robin"
    }
)
```

## 最佳实践

### 1. 任务设计
- 将复杂任务分解为更小、更易管理的子任务
- 确保任务描述清晰明确
- 为任务设置合理的预期输出

### 2. 智能体分工
- 根据专业领域分配智能体角色
- 避免智能体职责重叠
- 确保每个智能体都有明确的目标

### 3. 错误恢复
- 实现健壮的错误处理机制
- 设置合理的重试策略
- 监控执行性能和失败率

### 4. 资源管理
- 合理设置速率限制
- 使用缓存减少重复计算
- 监控内存和CPU使用情况

## 下一步

