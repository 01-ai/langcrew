---
title: 实体记忆
description: 跨对话跟踪实体和关系
---

# 实体记忆

实体记忆使用结构化存储跨对话跟踪实体（人员、组织、概念）。它维护实体信息及其关系，提供上下文感知的响应。

## 概述

实体记忆适用于：
- **人员跟踪**在客户服务或CRM系统中
- **组织管理**在业务应用中
- **概念学习**在教育系统中
- **关系映射**不同实体之间

## 配置

### 基本设置

```python
from langcrew.memory import MemoryConfig

memory_config = MemoryConfig(
    provider="sqlite",
    connection_string="sqlite:///entities.db",
    entity={
        "enabled": True,
    }
)
```

### 配置参数

| 参数 | 类型 | 描述 | 默认值 |
|------|------|------|--------|
| `enabled` | bool | 启用实体记忆 | True |

## 工作原理

### 实体识别和存储

实体记忆自动识别并存储实体信息：

```python
from langcrew import Crew
from langcrew.memory import MemoryConfig

memory_config = MemoryConfig(
    provider="sqlite",
    connection_string="sqlite:///entities.db",
    entity={"enabled": True}
)

crew = Crew(agents=[agent], memory=memory_config)

# 存储实体信息
crew.kickoff(
    inputs={"user_input": "Alice Johnson是TechCorp的CEO，总部位于旧金山"},
    thread_id="business_context"
)

# 后续查询可以引用实体
crew.kickoff(
    inputs={"user_input": "你对Alice了解什么？"},
    thread_id="entity_query"
)
```

### 实体类型和组织

实体记忆按类型组织实体：
- **Person**：具有姓名、角色和属性的个人
- **Organization**：公司、部门、团队
- **Location**：城市、国家、地址
- **Concept**：想法、技术、方法论
- **General**：其他实体类型

## 使用示例

### 客户关系管理

```python
from langcrew import Agent, Crew
from langcrew.memory import MemoryConfig

# 为CRM配置
memory_config = MemoryConfig(
    provider="postgresql",
    connection_string="postgresql://user:pass@localhost:5432/crm_db",
    entity={
        "enabled": True,
    }
)

crm_agent = Agent(
    role="客户关系管理员",
    goal="维护详细的客户关系和历史",
    backstory="您跟踪客户信息、偏好和交互历史"
)

crew = Crew(agents=[crm_agent], memory=memory_config)

# 建立客户档案
customer_interactions = [
    ("customer_001", "Emily Chen是DataFlow Inc的CTO，偏好邮件沟通"),
    ("customer_001", "DataFlow Inc是金融科技领域的50人初创公司"),
    ("customer_001", "Emily提到他们正在评估欺诈检测的AI解决方案"),
    ("customer_002", "Michael Rodriguez来自RetailPlus，对库存优化感兴趣"),
    ("customer_002", "RetailPlus在加利福尼亚和德克萨斯经营25家商店"),
]

for customer_id, info in customer_interactions:
    crew.kickoff(
        inputs={"user_input": info},
        thread_id=customer_id
    )

# 查询客户信息
result = crew.kickoff(
    inputs={"user_input": "我们对Emily Chen和她的公司了解什么？"},
    thread_id="customer_query"
)
```

## 实体管理

### 保存实体信息

```python
# 手动保存实体信息
crew.entity_memory.save(
    value="John是一名有8年Python经验的高级开发人员",
    metadata={
        "entity_name": "John",
        "entity_type": "person",
        "attributes": {
            "role": "senior developer",
            "experience": "8 years",
            "skills": ["Python"]
        },
        "relationships": [
            {"type": "works_at", "entity": "TechCorp"}
        ]
    },
    agent="hr_system"
)
```

### 搜索实体

```python
# 搜索特定实体
results = crew.search_memory(
    query="John",
    memory_type="entity",
    limit=5
)

for result in results:
    print(f"实体: {result['name']}")
    print(f"类型: {result['type']}")
    print(f"描述: {result['description']}")
    print(f"属性: {result['attributes']}")
    print(f"关系: {result['relationships']}")
```

### 获取实体详情

```python
# 获取特定实体信息
john_info = crew.entity_memory.get_entity(
    entity_name="John",
    entity_type="person"
)

if john_info:
    print(f"姓名: {john_info['name']}")
    print(f"类型: {john_info['type']}")
    print(f"描述: {john_info['description']}")
    print(f"提及次数: {john_info['mentions']}")
    print(f"最后更新: {john_info['last_updated']}")
```

## 最佳实践

### 实体命名策略

```python
# 使用一致的实体命名
entity_naming_rules = {
    "people": "FirstName LastName",           # "John Smith"
    "companies": "Company Name Inc/Corp",     # "TechCorp Inc"
    "locations": "City, State/Country",       # "San Francisco, CA"
    "concepts": "Concept Name",               # "Machine Learning"
}
```

### 关系建模

```python
# 定义清晰的关系类型
relationship_types = {
    "employment": ["works_at", "employed_by", "manages", "reports_to"],
    "business": ["partners_with", "competes_with", "supplies_to"],
    "location": ["located_in", "based_in", "operates_in"],
    "expertise": ["expert_in", "specializes_in", "teaches"],
    "family": ["related_to", "parent_of", "spouse_of"]
}
```

## 与其他内存类型集成

实体记忆与短期记忆和长期记忆协同工作：

```python
# 带有实体跟踪的全面内存
memory_config = MemoryConfig(
    provider="postgresql",
    connection_string="postgresql://...",
    short_term={"enabled": True, "max_history": 20},    # 近期上下文
    long_term={"enabled": True, "min_quality": 0.8},    # 重要知识
    entity={"enabled": True}                            # 实体关系
)

# 受益于所有内存类型：
# - 短期：近期对话上下文
# - 长期：重要事实和学习
# - 实体：结构化实体关系
```

## 下一步

- **[短期记忆](/zh/guides/memory/short-term)** - 基于会话的对话历史
- **[长期记忆](/zh/guides/memory/long-term)** - 持久知识存储
- **[存储配置](/zh/guides/memory/storage)** - 配置存储后端
- **[内存概念](/zh/concepts/memory)** - 理解内存架构